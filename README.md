# fixed-array-swift

## Example

```console
> generate-fixed-array --public --equatable --hashable 32
```

```swift
// Generated by generate-fixed-array v1.0.0-alpha on 2022-08-25T21:31:29Z.

public struct Array32<Element> {
    private var storage: (
        Element, Element, Element, Element, Element, Element, Element, Element,
        Element, Element, Element, Element, Element, Element, Element, Element,
        Element, Element, Element, Element, Element, Element, Element, Element,
        Element, Element, Element, Element, Element, Element, Element, Element
    )
    
    @inline(__always)
    public static var count: Int {
        32
    }
    
    @inline(__always)
    public static var indices: Range<Index> {
        0..<32
    }
    
    public init(repeating element: Element) {
        storage = (
            element, element, element, element, element, element, element, element,
            element, element, element, element, element, element, element, element,
            element, element, element, element, element, element, element, element,
            element, element, element, element, element, element, element, element
        )
    }
}

// MARK: -

extension Array32 where Element: AdditiveArithmetic {
    init() {
        storage = (
            .zero, .zero, .zero, .zero, .zero, .zero, .zero, .zero,
            .zero, .zero, .zero, .zero, .zero, .zero, .zero, .zero,
            .zero, .zero, .zero, .zero, .zero, .zero, .zero, .zero,
            .zero, .zero, .zero, .zero, .zero, .zero, .zero, .zero
        )
    }
    
    init(_ sequence: some Sequence<Element>) {
        self.init()
        var iterator = sequence.makeIterator()
        var index = startIndex
        while let element = iterator.next() {
            self[index] = element
            index += 1
        }
        precondition(index == endIndex, "Not enough elements in sequence.")
    }
}

// MARK: - ExpressibleByArrayLiteral

extension Array32: ExpressibleByArrayLiteral where Element: AdditiveArithmetic {
    public init(arrayLiteral: Element...) {
        self.init(arrayLiteral)
    }
}

// MARK: - MutableCollection, RandomAccessCollection

extension Array32: MutableCollection, RandomAccessCollection {
    public typealias Index = Int
    
    @inline(__always)
    public var startIndex: Index {
        0
    }
    
    @inline(__always)
    public var endIndex: Index {
        Self.count
    }
    
    @inline(__always)
    public subscript(position: Index) -> Element {
        get {
            precondition(indices.contains(position))
            return self[unchecked: position]
        }
        set {
            precondition(indices.contains(position))
            self[unchecked: position] = newValue
        }
    }
    
    @inline(__always)
    public var first: Element {
        get {
            self[startIndex]
        }
        set {
            self[startIndex] = newValue
        }
    }
    
    @inline(__always)
    public var last: Element {
        get {
            self[endIndex - 1]
        }
        set {
            self[endIndex - 1] = newValue
        }
    }
}

// MARK: -

extension Array32 {
    @inline(__always)
    public subscript(unchecked position: Index) -> Element {
        get {
            self.withUnsafeBufferPointer {
                $0[position]
            }
        }
        set {
            self.withUnsafeMutableBufferPointer {
                $0[position] = newValue
            }
        }
    }
    
    @inline(__always)
    public func withUnsafeBufferPointer<R>(
        _ body: (UnsafeBufferPointer<Element>) throws -> R
    ) rethrows -> R {
        try withUnsafePointer(to: self) {
            try body(UnsafeBufferPointer<Element>(
                start: UnsafeRawPointer($0).assumingMemoryBound(to: Element.self),
                count: Self.count
            ))
        }
    }
    
    @inline(__always)
    public mutating func withUnsafeMutableBufferPointer<R>(
        _ body: (UnsafeMutableBufferPointer<Element>) throws -> R
    ) rethrows -> R {
        try withUnsafeMutablePointer(to: &self) {
            try body(UnsafeMutableBufferPointer<Element>(
                start: UnsafeMutableRawPointer($0).assumingMemoryBound(to: Element.self),
                count: Self.count
            ))
        }
    }
}

// MARK: - Equatable

extension Array32: Equatable where Element: Equatable {
    public static func == (_ lhs: Self, _ rhs: Self) -> Bool {
        for elements in zip(lhs, rhs) {
            if elements.0 != elements.1 {
                return false
            }
        }
        return true
    }
}

extension Array32 where Element: BinaryInteger {
    public static func == (_ lhs: Self, _ rhs: Self) -> Bool {
        zip(lhs, rhs).lazy.map(^).reduce(.zero, |) == .zero
    }
}

extension Array32 where Element: SIMD, Element.Scalar: FixedWidthInteger {
    public static func == (_ lhs: Self, _ rhs: Self) -> Bool {
        zip(lhs, rhs).lazy.map(^).reduce(.zero, |) == .zero
    }
}

// MARK: - Hashable

extension Array32: Hashable where Element: Hashable {
    public func hash(into hasher: inout Hasher) {
        hasher.combine(Self.count)
        for element in self {
            hasher.combine(element)
        }
    }
}
```
