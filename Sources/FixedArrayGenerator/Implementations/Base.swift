import Algorithms
import Foundation

extension FixedArrayGenerator {
    var baseImplementation: String {
        """
        // Generated by generate-fixed-array v\(Self.configuration.version) on \
        \(Date.now.ISO8601Format()).
        
        \(publicPrefix)struct Array\(count)<Element> {
            private var storage: (
        \(repeatElement("Element", count: count)
            .lazy
            .chunks(ofCount: 8)
            .map({ "        " + $0.joined(separator: ", ") })
            .joined(separator: ",\n"))
            )
            
            @inline(__always)
            \(publicPrefix)static var count: Int {
                \(count)
            }
            
            @inline(__always)
            \(publicPrefix)static var indices: Range<Index> {
                0..<\(count)
            }
            
            \(publicPrefix)init(repeating element: Element) {
                storage = (
        \(repeatElement("element", count: count)
            .lazy
            .chunks(ofCount: 8)
            .map({ "            " + $0.joined(separator: ", ") })
            .joined(separator: ",\n"))
                )
            }
        }
        
        // MARK: -
        
        extension Array\(count) where Element: AdditiveArithmetic {
            init() {
                storage = (
        \(repeatElement(".zero", count: count)
            .lazy
            .chunks(ofCount: 8)
            .map({ "            " + $0.joined(separator: ", ") })
            .joined(separator: ",\n"))
                )
            }
            
            init(_ sequence: some Sequence<Element>) {
                self.init()
                var iterator = sequence.makeIterator()
                var index = startIndex
                while let element = iterator.next() {
                    self[index] = element
                    index += 1
                }
                precondition(index == endIndex, "Not enough elements in sequence.")
            }
        }
        
        // MARK: - ExpressibleByArrayLiteral
        
        extension Array\(count): ExpressibleByArrayLiteral where Element: AdditiveArithmetic {
            \(publicPrefix)init(arrayLiteral: Element...) {
                self.init(arrayLiteral)
            }
        }
        
        // MARK: - MutableCollection, RandomAccessCollection
        
        extension Array\(count): MutableCollection, RandomAccessCollection {
            \(publicPrefix)typealias Index = Int
            
            @inline(__always)
            \(publicPrefix)var startIndex: Index {
                0
            }
            
            @inline(__always)
            \(publicPrefix)var endIndex: Index {
                Self.count
            }
            
            @inline(__always)
            \(publicPrefix)subscript(position: Index) -> Element {
                get {
                    precondition(indices.contains(position))
                    return self[unchecked: position]
                }
                set {
                    precondition(indices.contains(position))
                    self[unchecked: position] = newValue
                }
            }
            
            @inline(__always)
            \(publicPrefix)var first: Element {
                get {
                    self[startIndex]
                }
                set {
                    self[startIndex] = newValue
                }
            }
            
            @inline(__always)
            \(publicPrefix)var last: Element {
                get {
                    self[endIndex - 1]
                }
                set {
                    self[endIndex - 1] = newValue
                }
            }
        }
        
        // MARK: -
        
        extension Array\(count) {
            @inline(__always)
            \(publicPrefix)subscript(unchecked position: Index) -> Element {
                get {
                    self.withUnsafeBufferPointer {
                        $0[position]
                    }
                }
                set {
                    self.withUnsafeMutableBufferPointer {
                        $0[position] = newValue
                    }
                }
            }
            
            @inline(__always)
            \(publicPrefix)func withUnsafeBufferPointer<R>(
                _ body: (UnsafeBufferPointer<Element>) throws -> R
            ) rethrows -> R {
                try withUnsafePointer(to: self) {
                    try body(UnsafeBufferPointer<Element>(
                        start: UnsafeRawPointer($0).assumingMemoryBound(to: Element.self),
                        count: Self.count
                    ))
                }
            }
            
            @inline(__always)
            \(publicPrefix)mutating func withUnsafeMutableBufferPointer<R>(
                _ body: (UnsafeMutableBufferPointer<Element>) throws -> R
            ) rethrows -> R {
                try withUnsafeMutablePointer(to: &self) {
                    try body(UnsafeMutableBufferPointer<Element>(
                        start: UnsafeMutableRawPointer($0).assumingMemoryBound(to: Element.self),
                        count: Self.count
                    ))
                }
            }
        }
        """
    }
}
